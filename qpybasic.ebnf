%ignore /[ \t\f]+/

program: _nl? _part*

_part: (_line | block | toplevel_block) _nl

_nl: _NEWLINE+

?block: for_block
      | do_block
      | if_block

?toplevel_block: sub_block
               | function_block
               | type_block

_line: [label | lineno] _stmt_group

_stmt_group: (stmt ":") _stmt_group
           | stmt?

label: ID ":"

lineno: NUMERIC_LITERAL

?stmt: call_stmt
     | cls_stmt
     | const_stmt
     | declare_stmt
     | deftype_stmt
     | dim_stmt
     | end_stmt
     | exit_stmt
     | gosub_stmt
     | goto_stmt
     | let_stmt
     | print_stmt
     | rem_stmt
     | return_stmt

for_block: _for_stmt block_body next_stmt

_for_stmt: FOR_KW ID "=" expr TO_KW expr step_phrase _nl

step_phrase: [STEP_KW expr]

next_stmt: NEXT_KW [ID]

if_block: IF_KW expr THEN_KW _NEWLINE block_body else_list END_KW IF_KW

else_list: ELSEIF_KW expr THEN_KW _NEWLINE block_body else_list  -> elseif_sub_block
         | ELSE_KW _NEWLINE block_body                           -> else_sub_block
         |

do_block: DO_KW _nl block_body LOOP_KW                              -> do_loop_forever
        | DO_KW (WHILE_KW | UNTIL_KW) expr _nl block_body LOOP_KW   -> do_loop_cond_top
        | DO_KW _nl block_body LOOP_KW (WHILE_KW | UNTIL_KW) expr   -> do_loop_cond_bottom

sub_block: SUB_KW ID parameter_list _NEWLINE block_body END_KW SUB_KW

parameter_list: "(" parameter_definition ("," parameter_definition)* ")"
              |

parameter_definition: ID lpar_rpar [AS_KW typename]

lpar_rpar: [LPAR RPAR]

typename: INTEGER_KW
        | LONG_KW
        | SINGLE_KW
        | DOUBLE_KW
        | STRING_KW
        | ID

function_block: FUNCTION_KW ID parameter_list _NEWLINE block_body END_KW FUNCTION_KW

block_body: _block_body_item*

_block_body_item: block _NEWLINE
                | _line _NEWLINE
                | _NEWLINE

type_block: TYPE_KW ID _nl (parameter_definition COMMENT_QUOTE? _nl)* END_KW TYPE_KW

call_stmt: lvalue argument_list
         | CALL_KW ID ["(" argument_list ")"]

argument_list: expr ("," expr)*
             |

cls_stmt: CLS_KW

const_stmt: CONST_KW ID "=" expr

declare_stmt: DECLARE_KW (SUB_KW | FUNCTION_KW) ID (parameter_list | "(" ")" )

deftype_stmt: (DEFINT_KW | DEFLNG_KW | DEFSNG_KW | DEFDBL_KW | DEFSTR_KW) letter_range ("," letter_range)*

// we're using ID here instead of single letters because it was
// conflicting with ID. so we'll check for single letters in the
// compiler.
letter_range: ID ["-" ID]

dim_stmt: DIM_KW shared_opt var_decl ("," var_decl)*

shared_opt: SHARED_KW?

var_decl: ID dimensions [AS_KW typename]

dimensions: "(" dimension ("," dimension)* ")"
          |

dimension: expr [TO_KW expr]

end_stmt: END_CMD

exit_stmt: EXIT_KW (SUB_KW | FUNCTION_KW | FOR_KW)

gosub_stmt: GOSUB_KW (ID | NUMERIC_LITERAL)

goto_stmt: GOTO_KW (ID | NUMERIC_LITERAL)

let_stmt: LET_KW? lvalue "=" expr

print_stmt: PRINT_KW (expr _print_sep)* expr
          | PRINT_KW expr [_print_sep]

_print_sep: SEMICOLON
          | COMMA

rem_stmt: COMMENT_REM

return_stmt: RETURN_KW

?expr: imp_expr

?imp_expr: eqv_expr
         | expr IMP_KW eqv_expr

?eqv_expr: xor_expr
         | eqv_expr EQV_KW xor_expr

?xor_expr: or_expr
         | xor_expr XOR_KW or_expr

?or_expr: and_expr
        | or_expr OR_KW and_expr

?and_expr: not_expr
         | and_expr AND_KW not_expr

?not_expr: compare_expr
         | NOT_KW compare_expr

?compare_expr: addsub_expr
             | compare_expr "<" addsub_expr   -> expr_lt
             | compare_expr ">" addsub_expr   -> expr_gt
             | compare_expr "<=" addsub_expr  -> expr_le
             | compare_expr ">=" addsub_expr  -> expr_ge
             | compare_expr "=" addsub_expr   -> expr_eq
             | compare_expr "<>" addsub_expr   -> expr_ne

?addsub_expr: muldiv_expr
            | addsub_expr "+" muldiv_expr  -> expr_add
            | addsub_expr "-" muldiv_expr  -> expr_sub

?muldiv_expr: unary_expr
            | muldiv_expr "*" unary_expr  -> expr_mul
            | muldiv_expr "/" unary_expr  -> expr_div

?unary_expr: value
           | "-" expr      -> negation
           | "(" expr ")"

value: NUMERIC_LITERAL
     | STRING_LITERAL
     | lvalue

lvalue: lv_base lv_suffix

lv_base: ID [LPAR argument_list RPAR]

lv_suffix: ("." ID)*

_NEWLINE: "\n"
        | "\r\n"
        | "\r"
        | ":"
SEMICOLON: ";"
COMMA: ","
LPAR: "("
RPAR: ")"
ID: /[a-z_][a-z0-9]*[!#%&$]?/i
INT_LITERAL: /\d+/
NUMERIC_LITERAL: /\d+(\.\d*)?[!#%&]?/
STRING_LITERAL: /"[^"]*"/

AND_KW: "and"i
AS_KW: "as"i
CALL_KW: "call"i
CLS_KW: "cls"i
CONST_KW: "const"i
DECLARE_KW: "declare"i
DEFDBL_KW: "defdbl"i
DEFINT_KW: "defint"i
DEFLNG_KW: "deflng"i
DEFSNG_KW: "defsng"i
DEFSTR_KW: "defstr"i
DIM_KW: "dim"i
DO_KW: "do"i
DOUBLE_KW: "double"i
ELSE_KW: "else"i
ELSEIF_KW: "elseif"i
END_KW: "end"i
EQV_KW: "eqv"i
EXIT_KW: "exit"i
FOR_KW: "for"i
FUNCTION_KW: "function"i
GOSUB_KW: "gosub"i
GOTO_KW: "goto"i
IF_KW: "if"i
IMP_KW: "imp"i
INTEGER_KW: "integer"i
LET_KW: "let"i
LONG_KW: "long"i
LOOP_KW: "loop"i
NEXT_KW: "next"i
NOT_KW: "not"i
OR_KW: "or"i
PRINT_KW: "print"i
RETURN_KW: "return"i
SHARED_KW: "shared"i
SINGLE_KW: "single"i
STEP_KW: "step"i
STRING_KW: "string"i
SUB_KW: "sub"i
THEN_KW: "then"i
TO_KW: "to"i
TYPE_KW: "type"i
UNTIL_KW: "until"i
WHILE_KW: "while"i
XOR_KW: "xor"i

COMMENT_QUOTE: /'[^\n]*/
COMMENT_REM: /rem /i /[^\n]/i*

%declare END_CMD