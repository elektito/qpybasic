%ignore /[ \t\f]+/

program: _nlopt _part_list

_part_list: _part _part_list
          |

_part: (_line | block | toplevel_block) _nl

_nlopt: _nl
      |

_nl: _NEWLINE _nl
   | _NEWLINE


?block: for_block
      | if_block

?toplevel_block: sub_block
               | function_block
               | type_block

_line: [label | lineno] _stmt_group

_stmt_group: (stmt ":") _stmt_group
           | stmt?

label: ID ":"

lineno: NUMERIC_LITERAL

?stmt: call_stmt
     | cls_stmt
     | declare_stmt
     | deftype_stmt
     | dim_stmt
     | end_stmt
     | goto_stmt
     | let_stmt
     | print_stmt

for_block: _for_stmt block_body next_stmt

_for_stmt: FOR_KW ID "=" expr TO_KW expr step_phrase _nl

step_phrase: [STEP_KW expr]

next_stmt: NEXT_KW [ID]

if_block: IF_KW expr THEN_KW _NEWLINE block_body else_list END_KW IF_KW

else_list: ELSEIF_KW expr THEN_KW _NEWLINE block_body else_list  -> elseif_sub_block
         | ELSE_KW _NEWLINE block_body                           -> else_sub_block
         |

sub_block: SUB_KW ID parameter_list _NEWLINE block_body END_KW SUB_KW

parameter_list: "(" parameter_definition ("," parameter_definition)* ")"
              |

parameter_definition: ID [AS_KW typename]

typename: INTEGER_KW
        | LONG_KW
        | SINGLE_KW
        | DOUBLE_KW
        | STRING_KW
        | ID

function_block: FUNCTION_KW ID parameter_list _NEWLINE block_body END_KW FUNCTION_KW

block_body: _block_body_item*

_block_body_item: block _NEWLINE
                | _line _NEWLINE
                | _NEWLINE

type_block: TYPE_KW ID _nl (parameter_definition (COMMENT? | _nl))* END_KW TYPE_KW

call_stmt: possibly_lvalue argument_list
         | CALL_KW ID "(" argument_list ")"

argument_list: expr ("," expr)*
             |

cls_stmt: CLS_KW

declare_stmt: DECLARE_KW (SUB_KW | FUNCTION_KW) ID (parameter_list | "(" ")" )

deftype_stmt: (DEFINT_KW | DEFLNG_KW | DEFSNG_KW | DEFDBL_KW | DEFSTR_KW) letter_range ("," letter_range)*

// we're using ID here instead of single letters because it was
// conflicting with ID. so we'll check for single letters in the
// compiler.
letter_range: ID ["-" ID]

dim_stmt: DIM_KW ID dimensions [AS_KW typename]

dimensions: "(" dimension ("," dimension)* ")"
          |

dimension: NUMERIC_LITERAL [TO_KW NUMERIC_LITERAL]

end_stmt: END_CMD

goto_stmt: GOTO_KW (ID | NUMERIC_LITERAL)

let_stmt: LET_KW? possibly_lvalue "=" expr

print_stmt: PRINT_KW (expr _print_sep)* expr
          | PRINT_KW expr [_print_sep]

_print_sep: SEMICOLON
          | COMMA


?expr: addsub_expr
     | expr "<" addsub_expr   -> expr_lt
     | expr ">" addsub_expr   -> expr_gt
     | expr "<=" addsub_expr  -> expr_le
     | expr ">=" addsub_expr  -> expr_ge
     | expr "=" addsub_expr   -> expr_eq
     | expr "<>" addsub_expr   -> expr_ne

?addsub_expr: muldiv_expr
            | addsub_expr "+" muldiv_expr  -> expr_add
            | addsub_expr "-" muldiv_expr  -> expr_sub

?muldiv_expr: unary_expr
            | muldiv_expr "*" unary_expr  -> expr_mul
            | muldiv_expr "/" unary_expr  -> expr_div

?unary_expr: value
           | "-" expr      -> negation
           | "(" expr ")"

value: NUMERIC_LITERAL
     | STRING_LITERAL
     | possibly_lvalue

possibly_lvalue: ID                                   -> var_or_no_arg_func
               | ID "(" argument_list ")"             -> func_call_or_idx
               | possibly_lvalue "." possibly_lvalue  -> dotted

_NEWLINE: "\n"
        | "\r\n"
        | "\r"
        | ":"
SEMICOLON: ";"
COMMA: ","
ID: /[a-z_][a-z0-9]*[!#%&$]?/i
INT_LITERAL: /\d+/
NUMERIC_LITERAL: /\d+(\.\d*)?[!#%&]?/
STRING_LITERAL: /"[^"]*"/

AS_KW: "as"i
CALL_KW: "call"i
CLS_KW: "cls"i
DECLARE_KW: "declare"i
DEFDBL_KW: "defdbl"i
DEFINT_KW: "defint"i
DEFLNG_KW: "deflng"i
DEFSNG_KW: "defsng"i
DEFSTR_KW: "defstr"i
DIM_KW: "dim"i
DOUBLE_KW: "double"i
ELSE_KW: "else"i
ELSEIF_KW: "elseif"i
END_KW: "end"i
FOR_KW: "for"i
FUNCTION_KW: "function"i
GOTO_KW: "goto"i
IF_KW: "if"i
INTEGER_KW: "integer"i
LET_KW: "let"i
LONG_KW: "long"i
NEXT_KW: "next"i
PRINT_KW: "print"i
SINGLE_KW: "single"i
STEP_KW: "step"i
STRING_KW: "string"i
SUB_KW: "sub"i
THEN_KW: "then"i
TO_KW: "to"i
TYPE_KW: "type"i

COMMENT: /('|[rR][eE][mM][ \t\f]).*\n/
%ignore COMMENT

%declare END_CMD